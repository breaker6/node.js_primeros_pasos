1.- Vamos a comenzar a crear nuestro primer servidor en el que albergaremos la api REST.
Para ello, ejecutamos npm install --save express para instalar express

2.- Introducimos este código en index.js (el archivo tiene que estar vacio)
//Importamos express
import express from 'express'

//Guardamos la instancia
let _server

//Generamos el objeto server con los metodos start y close
const server = {
  start () {
    //Creamos el servidor en express
    const app = express()

    //Guardamos la instancia y le decimos que escuche el puerto 9000
    _server = app.listen('9000', () => {
      //Si el entorno en el que estamos ejecutando es distinto de test
      if (process.env.NODE_ENV !== 'test') {
        //Que nos avise cuando este arrancando
        console.log('Server opened listen on http://localhost:9000')
      }
    })
  },
  //En close cerramos la instancia del servidor
  close () {
    _server.close()
  }
}

//Exportamos el objeto server
export default server

//Si se utiliza como modulo principal, que ejecute server.start()
if (!module.parent) {
  server.start()
}

3.- Ejecutamos npm run start y comprobamos que no hay errores

4.- Empezamos a configurar la API REST. Creamos dentro de src un fichero llamado config.js en el
que almacenaremos toda la informacion de nuestro servidor.

5.- Tendremos que instalar varios paquetes. Ejecutaremos en el terminal el siguiente comando:
npm install --save body-parser cors morgan

6.- Añadimos a config.js el siguiente codigo:
//Importamos body-parser
import bodyParser from 'body-parser'
//Importamos el logger morgan
import logger from 'morgan'
//Importamos cors
import cors from 'cors'

//Exportamos (la vamos a utilizar fuera) una funcion que por defecto recibirá la instancia del
//servidor creado
export default app => {
  //Desabilitamos el x-powered
  app.disable('x-powered-by')
 
  //Seteamos el entorno de desarrollo. Le decimos que nuestro entorno se define por
  //process.env.NODE_ENV
  app.set('env', process.env.NODE_ENV)

  //Desactivamos el logger en caso de los test
  if (process.env.NODE_ENV !== 'test') {
    //Usamos el formato de log combined que es el mas completo
    app.use(logger('combined'))
  }

  //Parsearenis todos los logs que nos lleguen a un formato visible
  app.use(bodyParser.json())
  app.use(bodyParser.urlencoded({ extended: false }))
 
  //Usamos cors. Cors permite configurar de forma automatica las cabeceras de la aplicacion
  app.use(cors())
}

7.- Añadimos en index.js el siguiente import en la parte de arriba a continuación del de express:
import config from './config'

Tambien debemos añadirla al server. Para ello, sustituiremos el
codigo de const server y todo su contenido por este:
const server = {
  start () {
    const app = express()
    //Recibimos el archivo de configuracion
    config(app)

    _server = app.listen('9000', () => {
      if (process.env.NODE_ENV !== 'test') {
        console.log('Server opened listen on http://localhost:9000')
      }
    })
  },
  close () {
    _server.close()
  }
}

8.- Ejecutamos npm run start para verificar que no hayan errores

9.- Ahora vamos a configurar el entorno de desarrollo o produccion. Para ello necesitaremos
la libreria dotenv que nos permitirá hacer muchas configuraciones. Para instalarla, ejecutar
en el terminal npm install --save dotenv

10.- Vamos a crear en la raiz del proyecto (en el nivel superior a src) un archivo llamado .env
en el que definiremos las variables de entorno. Introduciremos el siguiente codigo:
ENV=development
DEBUG=true
HOST=localhost
PORT=9000
TIMEZONE=Europe/Amsterdam

11.- Sustituir el codigo de config.js por este:
//Importamos body-parser
import bodyParser from 'body-parser'
//Importamos el logger morgan
import logger from 'morgan'
//Importamos cors
import cors from 'cors'
//Importamos solo la funcion config de la dependencia dotenv
import { config } from 'dotenv'

//Cargamos la configuracion en la constante settings. Esto guarda toda la informacion del
//fichero de configuracion
const SETTINGS = config()

//Exportamos (la vamos a utilizar fuera) una funcion que por defecto recibirá la instancia del
//servidor creado
export default app => {
  //Desabilitamos el x-powered
  app.disable('x-powered-by')
 
  //Seteamos el entorno de desarrollo. Le decimos que nuestro entorno se define por
  //process.env.NODE_ENV
  //app.set('env', process.env.NODE_ENV)
  //El entorno de desarrollo vendrá definido en la configuracion que esta almacenada en SETTINGS
  app.set('env', SETTINGS.parsed.ENV)
 
  //Seteamos la variable config y le decimos que guarde todos los datos de settings
  app.set('config', SETTINGS.parsed)
  //Le decimos que de forma local el entorno es env (variable seteada arriba)
  app.locals.env = app.get('env')
  //Seteamos el config en el config local
  app.locals.config = app.get('config')

  //Desactivamos el logger en caso de los test
  if (process.env.NODE_ENV !== 'test') {
    //Usamos el formato de log combined que es el mas completo
    app.use(logger('combined'))
  }

  //Parsearenis todos los logs que nos lleguen a un formato visible
  app.use(bodyParser.json())
  app.use(bodyParser.urlencoded({ extended: false }))
 
  //Usamos cors. Cors permite configurar de forma automatica las cabeceras de la aplicacion
  app.use(cors())
}

12.- Ejecutamos npm run start para verificar que no hay errores en el codigo

13.- Ahora añadiremos las rutas. Para ello, sobreescribiremos el objeto server (const server)
de index.js por este codigo:
const server = {
  start () {
    const app = express()

    config(app)

    // Rutas
    app.get('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo get' })
    })

    app.post('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo post' })
    })

    app.put('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo put' })
    })

    app.delete('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo delete' })
    })

    _server = app.listen(app.locals.config.PORT, () => {
      const address = _server.address()
      const host = address.address === '::'
        ? 'localhost'
        : address

      const port = app.locals.config.PORT
      if (process.env.NODE_ENV !== 'test') {
        console.log(`Server opened listen on http://${host}:${port}`)
      }
    })
  },
  close () {
    _server.close()
  }
}

14.- Ejecutamos npm run start para verificar que no hay errores

15.- Ahora crearemos rutas divididas de manera mas comoda. Creamos dentro de src el archivo
router.js con este codigo:
import music from './routes/music'
import user from './routes/me'

//Exportamos una funcion que rebirá app
export default app => {
  //Dependiendo para que ruta usaremos cosas distintas
  app.use('/me', user)
  app.use('/music', music)
}

16.- Creamos dentro de src un directorio routes y creamos el archivo me.js dentro de ella y le
pondremos este codigo:
//Importamos express para usar su funcion router
import express from 'express'

//Usaremos como router express.Router()
const router = express.Router()

//Nos definimos la ruta get /
router.get('/', (req, res, next) => {
  //Esta ruta devuelve un codigo de estado 200 y un json con datos
  res
    .status(200)
    .json({
      name: 'Fernando',
      lastname: 'Beltrán'
    })
})

//Exportamos el router
export default router

17.- Creamos dentro de routes el archivo music.js y le introducimos este codigo:
//Importamos express
import express from 'express'

//Importamos el archivo mocks que es el que tendrá la información a leer
import mocks from '../../mocks'

//Usamos el router de express
const router = express.Router()

//Creamos la ruta / que será accesible mediante get y post
router
  .get('/', (req, res, next) => {
    //Devolvemos el estado 200 y un json
    res
      .status(200)
      .json(mocks)
  })
  .post('/', (req, res, next) => {
    console.log('Body received:', req.body)
    //Devolvemos el estado 201 y un json
    res
      .status(201)
      .json(req.body)
  })

//Creamos una ruta que recibirá el nombre de un cantante
router.get('/:singer', (req, res, next) => {
  console.log('a', req.params.singer)
  //Le decimos que guarde la informacion del cantante almacenada en el archivo mocks
  const songsBySingers = mocks
    .filter(item =>
      item.singer.toLowerCase() === req.params.singer.toLowerCase()
    )

  //Le decimos que devuelva la informacion que ha leido en forma de json
  res
    .status(200)
    .json(songsBySingers)
})

//Exportamos el router
export default router

18.- Creamos en la raiz del proyecto (en el nivel superior de src) el archivo mocks.js con este
código:
export default [
  {
    singer: 'Moonboy',
    song: 'Postcards from Moon',
    album: 'Postcards from Moon'
  },
  {
    singer: 'Supermassive',
    song: 'The One',
    album: 'The One'
  },
  {
    singer: 'The Seed',
    song: 'The Roots',
    album: 'Phrenology'
  },
  {
    singer: 'Robin Schulz',
    song: 'Fools',
    album: 'OK'
  },
  {
    singer: 'Robin Schulz',
    song: 'OK',
    album: 'OK'
  },
  {
    singer: 'RagnBone',
    song: 'Human',
    album: 'Human'
  },
  {
    singer: 'Charlie Puth',
    song: 'How Long',
    album: 'How long'
  }
]

Estos serán los datos que utilizaremos en las rutas. Los guardamos en un array

19.- Eliminamos las rutas creadas en el archivo index.js y las sustituimos por este código:
config(app)
router(app)

También es necesario decirle que utilice router. Para ello, añadimos al principio del archivo
index.js el siguiente codigo:
import router from './router'

20.- Ejecutamos npm run start para verificar que no hay errores. Con la aplicacion postman
podemos verificar que las llamadas a las rutas funcionen de manera correcta.

21.- Ahora vamos a añadirle un token para securizar nuestro servidor. Debemos instalar una libreria
llamada jwt-simple con este comando en el terminal:
npm i -save jwt-simple

Esta libreria permite trabajar con tun token llamado jwt

22.- Debemos de crear un middleware para que cuando entre a una ruta, el usuario tiene el token de
autentificacion. Para ello, creamos dentro de src el archivo middlewares.js con este codigo:
//Importamos la libreria del token
import jwt from 'jwt-simple'

//Exportamos una variable llamada auth que recibe request, response y next
export const auth = (req, res, next) => {
  //Si la peticion http que nos estan enviando tiene como cabecera un authorization
  if (!req.headers.authorization) {
    //Si la cabecera no tiene autentificacion, mandaremos el codigo 403 y el mensaje un
    //autentificado
    return res
      .status(403)
      .send({ message: 'No authenticate' })
  }
 
  //Si continua la ejecución, generamos el token y lo dividimos por espacios
  const token = req.headers.authorization.split(' ')[1]
  //Generamos un payload que decodifique el token enviado. Usaremos una variable de entorno TOKEN
  const payload = jwt.decode(token, req.app.locals.config.TOKEN)

  //Definimos una request user que será igual al payload.email
  req.user = payload.email

  next()
}

23.- En nuestras variables de entorno (el archivo .env) añadiremos esta linea al final
TOKEN=1234567890

24.- En el archivo music.js añadiremos añadiremos el middleware de autentificación con este
codigo:
import { auth } from '../middlewares'

También en las rutas habrá que hacer una modificación. Para ello cambiaremos esta linea:
//La llamada a / desde el metodo post
.post('/', (req, res, next) => {

Por esta:
//auth añade el token de autentificación
.post('/', auth, (req, res, next) => {

25.- Eliminaremos todo el codigo de router.js y pondremos este:
import music from './routes/music'
import auth from './routes/auth'
import user from './routes/me'

export default app => {
  app.use('/auth', auth)
  app.use('/me', user)
  app.use('/music', music)
}

Es igual pero añadiendo auth.

26.- Creamos dentro de routes el archivo auth.js (nueva ruta) con el siguiente codigo:
//Importamos express
import express from 'express'
//Importamos la libreria del token
import jwt from 'jwt-simple'

//Creamos el router
const router = express.Router()

//Creamos la ruta
router
  .post('/', (req, res, next) => {
    //Guardamos como payload un objeto llamado email que obtendremos de params
    const payload = {
      email: req.params.email
    }

    //Devolveremos en una response el token que vamos a generar con el payload y con la clave
    //secreta que hemos creado
    return res
      .status(200)
      .send({ token: jwt.encode(payload, req.app.locals.config.TOKEN) })
  })

//Exportamos el router
export default router

27.- Ejecutamos npm run start en el terminal para verificar que no hay errores. con postman
podremos hacer las pruebas. Podremos acceder a todas las rutas salvo a barra /music porque no
tenemos token de autorizacion. para tenerlo habrá que llamar a la ruta auth enviandole
una key email y un value valido y recibiremos el token. Si lo añadimos a nuestra peticion
con key authorization y value JWT y el token ya accederá sin problema

1.- Vamos a realizar una implementacion basica de socket en la api rest. Para ello tenemos
que instalar la libreria websocket con este comando:
npm i --save ws

2.- Creamos un fichero dentro de src llamado socket.js con este codigo:
//Importamos la libreria websocket
import WebSocket from 'ws'

//Guardamos una instancia por si acaso
let instance
//Creamos una libreria que usar en la aplicacion
//Creamos la constante connect que generará un socket que usará el puerto 8080
export const connect = () => {
  const socket = new WebSocket.Server({ port: 8080 })

  //Cuando le llegue un evento llamado connection
  socket.on('connection', ws => {
    //Asignaremos el parametro ws recibido a la instancia creada
    instance = ws
    //Enviaremos a quien nos esté escuchando el texto
    ws.send('Connectado al socket')
  })
}

//Creamos la funcion send que recibe un method, una url y un dato
export const send = (method, url, data) => {
  //Comprobamos si existe una instancia
  if (instance) {
    //Si existe, mandaremos una cadena de texto
    instance.send(`${method} ${url} ${JSON.stringify(data)}`)
  }
}

3.- En el fichero index.js debemos añadir el socket. Para ello, añadimos este codigo en la parte
inicial:
import { connect } from './socket'

Además, cuando se conecta el servidor, hay que conectarlo. Para ello, en index.js justo después
de la linea _server = app.listen(app.locals.config.PORT, () => { hay que añadir este codigo:
connect()

3.- Ejecutamos npm run start para ver si hay errores.

4.- Instalamos en chrome la extension Smart Websocket client y ponemos en el espacio de la
url ws://localhost:8080 y le pulsamos connect para verificar que conecta

5.- Ahora añadiremos un mensaje a la conexion. Para ello añadiremos al principio de music.js 
(dentro de la carpeta routes) el siguiente codigo:
import { send as wsSend } from '../socket'

También será necesario añadir después de la linea .get('/', (req, res, next) => { el codigo:
//Cuando el usuario haga una peticion a /music mandaremos el mensaje
wsSend(req.method, req.baseUrl, mocks)

Después será necesario en la peticion get a /:singer añadir justo antes del metodo res el siguiente codigo:
//Cuando el usuario haga una peticion a /:singer mandaremos el mensaje
wsSend(req.method, req.baseUrl, songsBySingers)

El codigo de este metodo pasaría a ser así:
router
  .get('/:singer', (req, res, next) => {
    const songsBySingers = mocks
      .filter(item =>
        item.singer.toLowerCase() === req.params.singer.toLowerCase()
      )

    wsSend(req.method, req.baseUrl, songsBySingers)

    res
      .status(200)
      .json(songsBySingers)
})

6.- Ejecutamos npm run start para verificar que no hay errores.

7.- Ejecutamos en chrome la extension Smart Websocket client y ponemos en el espacio de la
url ws://localhost:8080 y le pulsamos connect para verificar que devuelve el mensaje. El mensaje
aparecerá en el terminal