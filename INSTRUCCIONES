1.- Vamos a comenzar a crear nuestro primer servidor en el que albergaremos la api REST.
Para ello, ejecutamos npm install --save express para instalar express

2.- Introducimos este código en index.js (el archivo tiene que estar vacio)
//Importamos express
import express from 'express'

//Guardamos la instancia
let _server

//Generamos el objeto server con los metodos start y close
const server = {
  start () {
    //Creamos el servidor en express
    const app = express()

    //Guardamos la instancia y le decimos que escuche el puerto 9000
    _server = app.listen('9000', () => {
      //Si el entorno en el que estamos ejecutando es distinto de test
      if (process.env.NODE_ENV !== 'test') {
        //Que nos avise cuando este arrancando
        console.log('Server opened listen on http://localhost:9000')
      }
    })
  },
  //En close cerramos la instancia del servidor
  close () {
    _server.close()
  }
}

//Exportamos el objeto server
export default server

//Si se utiliza como modulo principal, que ejecute server.start()
if (!module.parent) {
  server.start()
}

3.- Ejecutamos npm run start y comprobamos que no hay errores

4.- Empezamos a configurar la API REST. Creamos dentro de src un fichero llamado config.js en el
que almacenaremos toda la informacion de nuestro servidor.

5.- Tendremos que instalar varios paquetes. Ejecutaremos en el terminal el siguiente comando:
npm install --save body-parser cors morgan

6.- Añadimos a config.js el siguiente codigo:
//Importamos body-parser
import bodyParser from 'body-parser'
//Importamos el logger morgan
import logger from 'morgan'
//Importamos cors
import cors from 'cors'

//Exportamos (la vamos a utilizar fuera) una funcion que por defecto recibirá la instancia del
//servidor creado
export default app => {
  //Desabilitamos el x-powered
  app.disable('x-powered-by')
 
  //Seteamos el entorno de desarrollo. Le decimos que nuestro entorno se define por
  //process.env.NODE_ENV
  app.set('env', process.env.NODE_ENV)

  //Desactivamos el logger en caso de los test
  if (process.env.NODE_ENV !== 'test') {
    //Usamos el formato de log combined que es el mas completo
    app.use(logger('combined'))
  }

  //Parsearenis todos los logs que nos lleguen a un formato visible
  app.use(bodyParser.json())
  app.use(bodyParser.urlencoded({ extended: false }))
 
  //Usamos cors. Cors permite configurar de forma automatica las cabeceras de la aplicacion
  app.use(cors())
}

7.- Añadimos en index.js el siguiente import en la parte de arriba a continuación del de express:
import config from './config'

Tambien debemos añadirla al server. Para ello, sustituiremos el
codigo de const server y todo su contenido por este:
const server = {
  start () {
    const app = express()
    //Recibimos el archivo de configuracion
    config(app)

    _server = app.listen('9000', () => {
      if (process.env.NODE_ENV !== 'test') {
        console.log('Server opened listen on http://localhost:9000')
      }
    })
  },
  close () {
    _server.close()
  }
}

8.- Ejecutamos npm run start para verificar que no hayan errores

9.- Ahora vamos a configurar el entorno de desarrollo o produccion. Para ello necesitaremos
la libreria dotenv que nos permitirá hacer muchas configuraciones. Para instalarla, ejecutar
en el terminal npm install --save dotenv

10.- Vamos a crear en la raiz del proyecto (en el nivel superior a src) un archivo llamado .env
en el que definiremos las variables de entorno. Introduciremos el siguiente codigo:
ENV=development
DEBUG=true
HOST=localhost
PORT=9000
TIMEZONE=Europe/Amsterdam

11.- Sustituir el codigo de config.js por este:
//Importamos body-parser
import bodyParser from 'body-parser'
//Importamos el logger morgan
import logger from 'morgan'
//Importamos cors
import cors from 'cors'
//Importamos solo la funcion config de la dependencia dotenv
import { config } from 'dotenv'

//Cargamos la configuracion en la constante settings. Esto guarda toda la informacion del
//fichero de configuracion
const SETTINGS = config()

//Exportamos (la vamos a utilizar fuera) una funcion que por defecto recibirá la instancia del
//servidor creado
export default app => {
  //Desabilitamos el x-powered
  app.disable('x-powered-by')
 
  //Seteamos el entorno de desarrollo. Le decimos que nuestro entorno se define por
  //process.env.NODE_ENV
  //app.set('env', process.env.NODE_ENV)
  //El entorno de desarrollo vendrá definido en la configuracion que esta almacenada en SETTINGS
  app.set('env', SETTINGS.parsed.ENV)
 
  //Seteamos la variable config y le decimos que guarde todos los datos de settings
  app.set('config', SETTINGS.parsed)
  //Le decimos que de forma local el entorno es env (variable seteada arriba)
  app.locals.env = app.get('env')
  //Seteamos el config en el config local
  app.locals.config = app.get('config')

  //Desactivamos el logger en caso de los test
  if (process.env.NODE_ENV !== 'test') {
    //Usamos el formato de log combined que es el mas completo
    app.use(logger('combined'))
  }

  //Parsearenis todos los logs que nos lleguen a un formato visible
  app.use(bodyParser.json())
  app.use(bodyParser.urlencoded({ extended: false }))
 
  //Usamos cors. Cors permite configurar de forma automatica las cabeceras de la aplicacion
  app.use(cors())
}

12.- Ejecutamos npm run start para verificar que no hay errores en el codigo

13.- Ahora añadiremos las rutas. Para ello, sobreescribiremos el objeto server (const server)
de index.js por este codigo:
const server = {
  start () {
    const app = express()

    config(app)

    // Rutas
    app.get('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo get' })
    })

    app.post('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo post' })
    })

    app.put('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo put' })
    })

    app.delete('/', (req, res, next) => {
      res
         //Devolvermos el status 200 (todo ha ido bien y un objeto json)
        .status(200)
        .json({ data: 'metodo delete' })
    })

    _server = app.listen(app.locals.config.PORT, () => {
      const address = _server.address()
      const host = address.address === '::'
        ? 'localhost'
        : address

      const port = app.locals.config.PORT
      if (process.env.NODE_ENV !== 'test') {
        console.log(`Server opened listen on http://${host}:${port}`)
      }
    })
  },
  close () {
    _server.close()
  }
}

14.- Ejecutamos npm run start para verificar que no hay errores

15.- Ahora crearemos rutas divididas de manera mas comoda. Creamos dentro de src el archivo
router.js con este codigo:
import music from './routes/music'
import user from './routes/me'

//Exportamos una funcion que rebirá app
export default app => {
  //Dependiendo para que ruta usaremos cosas distintas
  app.use('/me', user)
  app.use('/music', music)
}

16.- Creamos dentro de src un directorio routes y creamos el archivo me.js dentro de ella y le
pondremos este codigo:
//Importamos express para usar su funcion router
import express from 'express'

//Usaremos como router express.Router()
const router = express.Router()

//Nos definimos la ruta get /
router.get('/', (req, res, next) => {
  //Esta ruta devuelve un codigo de estado 200 y un json con datos
  res
    .status(200)
    .json({
      name: 'Fernando',
      lastname: 'Beltrán'
    })
})

//Exportamos el router
export default router

17.- Creamos dentro de routes el archivo music.js y le introducimos este codigo:
//Importamos express
import express from 'express'

//Importamos el archivo mocks que es el que tendrá la información a leer
import mocks from '../../mocks'

//Usamos el router de express
const router = express.Router()

//Creamos la ruta / que será accesible mediante get y post
router
  .get('/', (req, res, next) => {
    //Devolvemos el estado 200 y un json
    res
      .status(200)
      .json(mocks)
  })
  .post('/', (req, res, next) => {
    console.log('Body received:', req.body)
    //Devolvemos el estado 201 y un json
    res
      .status(201)
      .json(req.body)
  })

//Creamos una ruta que recibirá el nombre de un cantante
router.get('/:singer', (req, res, next) => {
  console.log('a', req.params.singer)
  //Le decimos que guarde la informacion del cantante almacenada en el archivo mocks
  const songsBySingers = mocks
    .filter(item =>
      item.singer.toLowerCase() === req.params.singer.toLowerCase()
    )

  //Le decimos que devuelva la informacion que ha leido en forma de json
  res
    .status(200)
    .json(songsBySingers)
})

//Exportamos el router
export default router

18.- Creamos en la raiz del proyecto (en el nivel superior de src) el archivo mocks.js con este
código:
export default [
  {
    singer: 'Moonboy',
    song: 'Postcards from Moon',
    album: 'Postcards from Moon'
  },
  {
    singer: 'Supermassive',
    song: 'The One',
    album: 'The One'
  },
  {
    singer: 'The Seed',
    song: 'The Roots',
    album: 'Phrenology'
  },
  {
    singer: 'Robin Schulz',
    song: 'Fools',
    album: 'OK'
  },
  {
    singer: 'Robin Schulz',
    song: 'OK',
    album: 'OK'
  },
  {
    singer: 'RagnBone',
    song: 'Human',
    album: 'Human'
  },
  {
    singer: 'Charlie Puth',
    song: 'How Long',
    album: 'How long'
  }
]

Estos serán los datos que utilizaremos en las rutas. Los guardamos en un array

19.- Eliminamos las rutas creadas en el archivo index.js y las sustituimos por este código:
config(app)
router(app)

También es necesario decirle que utilice router. Para ello, añadimos al principio del archivo
index.js el siguiente codigo:
import router from './router'

20.- Ejecutamos npm run start para verificar que no hay errores. Con la aplicacion postman
podemos verificar que las llamadas a las rutas funcionen de manera correcta.